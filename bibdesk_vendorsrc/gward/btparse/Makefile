# 
# Main makefile for the btparse distribution.  This applies equally to my
# development version and the offical distribution; the differences are
# isolated in Makefile.defs (which, in the distributed version, is generated
# by `configure').
#
# Thus, you shouldn't have to change anything here.
#
# $Id: Makefile,v 1.17 2000/12/23 03:50:42 greg Exp $
#

include Makefile.defs		# CC, OPT, CFLAGS, etc.
include Makefile.version        # for building documentation and distribution


# Input files

GRAMMAR = src/bibtex

LIBSRC =\
   src/init.c\
   src/input.c\
   $(SCAN).c\
   $(ERR).c\
   $(GRAMMAR).c\
   src/error.c\
   src/lex_auxiliary.c\
   src/parse_auxiliary.c\
   src/bibtex_ast.c\
   src/sym.c\
   src/util.c\
   src/postprocess.c\
   src/macros.c\
   src/traversal.c\
   src/modify.c\
   src/names.c\
   src/tex_tree.c\
   src/string_util.c\
   src/format_name.c

LIBOBJ  = $(LIBSRC:.c=.o)
LIB     = libbtparse.a
SHLIB   = libbtparse.so
INCLUDE = src/btparse.h

# Directories to descend for "make clean"
DIRS    = src doc progs t

# Lexer-related files generated by antlr:
TOKENS = src/tokens.h
DLG_FILE = src/parser.dlg

# Files generated by dlg (both .c and .h files are generated)
SCAN = src/scan
ERR = src/err

# Files generated by antlr from the grammar (apart from $(GRAMMAR).c)
MODE = src/mode.h
PCCTS_H = src/stdpccts.h

# File generated by run_pccts to mark the time of the last PCCTS run
PCCTS_RUN = src/.pccts_run


# The outputs of antlr and dlg
GRAMMAR_SPAWN = $(GRAMMAR).c $(ERR).c $(PCCTS_H)
LEXER_SPAWN = $(DLG_FILE) $(TOKENS)
DLG_SPAWN = $(SCAN).c $(MODE)
PCCTS_SRC = $(SCAN).c $(ERR).c $(GRAMMAR).c
PCCTS_OBJ = $(PCCTS_SRC:.c=.o)

# -- Implicit targets --------------------------------------------------

.SUFFIXES: .i

# Replace the standard implicit .c.o rule to use both CFLAGS and CPPFLAGS,
# in the GNU manner (ie. like autoconf expects)
.c.o :
	$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $(<:.c=.o)

# This is handy for debugging on occasion (stripcpp is a sed hack of
# my own devising, and indent is just GNU indent).
.c.i :
	$(CC) $(CFLAGS) $(CPPFLAGS) -E $< | stripcpp | indent > $@


# -- Explicit targets --------------------------------------------------

lib : $(LIB)
	@echo $(LIB) is up to date.

shlib : $(SHLIB)
	@echo $(SHLIB) is up to date.

$(LIB) : $(LIBOBJ)
	$(AR) $(ARFLAGS) $@ $?
	@if [ -n "$(RANLIB)" ]; then \
	  echo $(RANLIB) $(LIB) ; \
	  $(RANLIB) $(LIB) ; \
	fi

$(SHLIB) : $(LIBOBJ)
	$(CC) -shared -o $(SHLIB) $(LIBOBJ)

$(GRAMMAR).o : $(GRAMMAR).c $(MODE) $(TOKENS)
	$(CC) $(CFLAGS2) $(CPPFLAGS) -c $< -o $(<:.c=.o)
$(SCAN).o : $(SCAN).c $(MODE) $(TOKENS)
	$(CC) $(CFLAGS2) $(CPPFLAGS) -c $< -o $(<:.c=.o)
$(ERR).o : $(ERR).c $(MODE) $(TOKENS)
	$(CC) $(CFLAGS2) $(CPPFLAGS) -c $< -o $(<:.c=.o)

$(PCCTS_RUN) : $(GRAMMAR).g
	$(PERL) $(RUN_PCCTS) $(AFLAGS) $(GRAMMAR).g

$(LEXER_SPAWN) $(GRAMMAR_SPAWN) $(DLG_SPAWN) : $(PCCTS_RUN)

man:
	cd doc ; $(MAKE) man

test: $(LIB)
	cd t ; $(MAKE) test

install: $(LIB)
	$(INSTALL) -d $(INSTALL_INC)
	$(INSTALL) -d $(INSTALL_LIB)
	$(INSTALL) -m 0644 $(INCLUDE) $(INSTALL_INC)
	$(INSTALL) -m 0644 $(LIB) $(INSTALL_LIB)
	cd doc ; $(MAKE) install

uninstall:
	rm -f $(INSTALL_INC)/$(INCLUDE)
	rm -f $(INSTALL_LIB)/$(LIB)
	cd doc ; $(MAKE) uninstall

# `clean' removes binary files, and leaves the package fully configured
# and ready to build again.
clean:
	rm -f $(LIBOBJ) core logfile
	for d in $(DIRS) ; do cd $$d ; $(MAKE) clean ; cd .. ; done

# `distclean' cleans, and then additionally removes everything done 
# to configure the package; the idea is to put the package back the
# way it was when it was unpacked.
distclean: clean
	rm -f config.cache config.log config.status
	rm -f Makefile.defs bt_config.h btparse.h
	cat < /dev/null > .depend
	cat < /dev/null > progs/.depend

# `scrub' cleans, and then removes any files that can be automatically
# generated but are included with the distribution (ie. PCCTS output).
# This means that if you `scrub', you'll need to have the software that
# generates those files (PCCTS).
scrub: clean
	@echo 'warning: using "make scrub" means you will need PCCTS to rebuild the package'
	rm -f $(LIB) $(SHLIB) $(GRAMMAR_SPAWN) $(LEXER_SPAWN) $(DLG_SPAWN)
	rm -f $(PCCTS_RUN)
	rm -rf src/temp

dep .depend: $(LIBSRC)
	$(CC) $(CFLAGS) $(CPPFLAGS) -M -MM $(SRC) $(LIBSRC) | \
	  sed 's|^\(.*\)\.o:|src/\1.o:|g' \
	  > .depend


# stuff for making a release (VERSION comes from Makefile.version)

DISTRIB = btparse
RELEASE = $(DISTRIB)-$(VERSION)
ARCHIVE = $(RELEASE).tar.gz

NAME_SYM = $(DISTRIB)_v$(VERSION_SYM)
CI       = ci -q -u -d
STATE    = Rel
RCSNAME  = rcs -q -n$(NAME_SYM): -s$(STATE)
CO       = co -q -u -r$(NAME_SYM) -M

rcsname :
	@files=`perl -MFile::Basename -n -e '$$rcsfile = dirname ($$_) . "/RCS/" . basename ($$_) . ",v";' -e 'print if -e $$rcsfile' MANIFEST` ;\
	echo $(RCSNAME) $$files ;\
	$(RCSNAME) $$files ;\
	echo $(CO) $$files ;\
	$(CO) $$files ;

cvstag :
	cvs tag $(NAME_SYM)
	cvs admin -s$(STATE)

distprep : man $(GRAMMAR_SPAWN) $(LEXER_SPAWN) $(DLG_SPAWN) configure

dist : distprep
	if [ -d $(RELEASE) ]; then rm -rf $(RELEASE); fi
	$(PERL) -MExtUtils::Manifest='/^mani/' \
	  -e '$$mani = maniread();' \
	  -e 'manicopy($$mani, "$(RELEASE)", "best");'
	cat < /dev/null > $(RELEASE)/$(PCCTS_RUN)
	cat < /dev/null > $(RELEASE)/.depend
	cat < /dev/null > $(RELEASE)/progs/.depend
	tar -czf $(ARCHIVE) $(RELEASE)
#	mv $(ARCHIVE) ../..
	rm -rf $(RELEASE)

configure : configure.in
	autoconf

# header dependencies (generated by "make dep")
include .depend
