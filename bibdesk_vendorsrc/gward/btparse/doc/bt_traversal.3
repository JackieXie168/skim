.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH bt_traversal 3 "btparse, version 0.33" "22 Decemer, 2000" "btparse"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
bt_traversal \- AST traversal/query functions in \fBbtparse\fR library
.SH "SYNOPSIS"
.PP
.Vb 7
\&   AST * bt_next_entry (AST * entry_list, 
\&                        AST * prev_entry)
\&   AST * bt_next_field  (AST * entry, AST * prev, char ** name)
\&   AST * bt_next_value  (AST * head, 
\&                         AST * prev,
\&                         bt_nodetype_t * nodetype,
\&                         char ** text)
.Ve
.Vb 4
\&   bt_metatype_t bt_entry_metatype (AST * entry)
\&   char * bt_entry_type (AST * entry)
\&   char * bt_entry_key   (AST * entry)
\&   char * bt_get_text   (AST * node)
.Ve
.SH "DESCRIPTION"
The functions described here are all used to traverse and query the
abstract-syntax trees (ASTs) returned by the input functions described
in the \fIbt_input\fR manpage.  The three \*(L"bt_next\*(R" functions (\f(CWbt_next_entry()\fR,
\f(CWbt_next_field()\fR, and \f(CWbt_next_value()\fR) are used respectively to
traverse a list of entries, the list of fields within a particular
entry, and the list of simple values associated with a particular field.
The other functions are just used to query various nodes in the tree for
the useful information contained in them.
.Sh "Traversal functions"
.Ip "bt_next_entry()" 4
.Sp
.Vb 2
\&   AST * bt_next_entry (AST * entry_list, 
\&                        AST * prev_entry)
.Ve
Used to traverse the linked list of entries returned by
\f(CWbt_parse_file()\fR (see the \fIbt_input\fR manpage).  On the first call, you should
supply \f(CWNULL\fR for \f(CWprev_entry\fR, and a pointer to the head of the list
will be returned.  On subsequent calls, pass the previous return value
as \f(CWprev_entry\fR; the function returns the next entry in the list, or
\f(CWNULL\fR if there are no more entries.  Also returns \f(CWNULL\fR if either
\f(CWentry_list\fR or \f(CWprev_entry\fR are improper.
.Sp
For example (ignoring error handling and variable declarations):
.Sp
.Vb 6
\&   entries = bt_parse_file (filename, options, &status);
\&   entry = NULL;
\&   while (entry = bt_next_entry (entries, entry))
\&   {
\&      /* process entry */
\&   }
.Ve
.Ip "bt_next_field()" 4
.Sp
.Vb 1
\&   AST * bt_next_field  (AST * entry, AST * prev, char ** name)
.Ve
Used to traverse the list of fields in a regular or macro definition
entry.  (You should call \f(CWbt_entry_metatype()\fR to determine if you have
the right kind of entry before calling \f(CWbt_next_field()\fR.)  \f(CWentry\fR
should be a pointer to the \s-1AST\s0 for a single entry, as returned by
\f(CWbt_parse_entry()\fR, \f(CWbt_parse_entry_s()\fR, or \f(CWbt_next_entry()\fR.  On
the first call, supply \f(CWNULL\fR for \f(CWprev\fR; \f(CWbt_next_field()\fR will
return a pointer to the first field in \f(CWentry\fR, or \f(CWNULL\fR if \f(CWentry\fR
has no fields (for instance, if it's a comment or preamble entry).  On
subsequent calls, pass the previous return value as \f(CWprev\fR;
\f(CWbt_next_field()\fR will keep returning pointers to field sub-ASTs as
long as it makes sense.  These pointers can then be passed to
\f(CWbt_next_value()\fR or \f(CWbt_get_text()\fR to get the field's value.
.Sp
For example, the loop body in the previous example could be:
.Sp
.Vb 5
\&   field = NULL;
\&   while (field = bt_next_field (entry, field, &field_name))
\&   {
\&      /* process field */
\&   }
.Ve
.Ip "bt_next_value()" 4
.Sp
.Vb 4
\&   AST * bt_next_value (AST * head, 
\&                        AST * prev,
\&                        bt_nodetype_t * nodetype,
\&                        char ** text)
.Ve
Traverses the list of simple values that make up the value of a single
field.  (Recall that a simple value is either a quoted string, a macro
invocation, or a number.  A compound value is a list of these separated
by \f(CW'#'\fR in the original input.  Depending on the string
post-processing options used when the data was parsed, the \*(L"list of
simple values\*(R" nature of the original data may be preserved in the \s-1AST\s0
that you're traversing, in which case you'll need a \f(CWbt_next_value()\fR
loop.
.Sp
\f(CWbt_next_value()\fR works much like \f(CWbt_next_entry()\fR and
\f(CWbt_next_field()\fR: on the first call, you supply \f(CWNULL\fR for \f(CWprev\fR,
and on subsequent calls you supply the previous return value.  Returns
\f(CWNULL\fR when there are no more simple values to return.  Also sets
\f(CW*nodetype\fR and \f(CW*text\fR to the corresponding information from the
simple value node.  \f(CW*nodetype\fR will be one of \f(CWBTAST_STRING\fR,
\f(CWBTAST_MACRO\fR, or \f(CWBTAST_NUMBER\fR; \f(CW*text\fR will point to the same
string as the \s-1AST\s0 node does (it is not copied for you), so don't mess
with it.  
.Sp
For example, the loop body in the \f(CWbt_next_field()\fR example could be
replaced with:
.Sp
.Vb 10
\&   value = NULL;
\&   while (value = bt_next_field (field, value, &nodetype, &text))
\&   {
\&      switch (nodetype)
\&      {
\&         case BTAST_STRING:    /* process the string */
\&         case BTAST_MACRO:     /* process the macro */
\&         case BTAST_NUMBER:    /* process the number */
\&      }
\&   }
.Ve
See also the \f(CWbt_get_text\fR entry elsewhere in this document.
.Sh "Query functions"
.Ip "bt_entry_metatype()" 4
.Sp
.Vb 1
\&   bt_metatype_t bt_entry_metatype (AST * entry)
.Ve
Returns the metatype of an entry.  (Recall that the \fImetatype\fR is an
enumerated type whose values are derived from the specific type of an
entry; for instance, an \f(CW@comment\fR entry has type \f(CW"comment"\fR and
metatype \f(CWBTE_COMMENT\fR.  The type-metatype relationship is similarly
obvious for \f(CWBTE_PREAMBLE\fR; \f(CWBTE_MACRODEF\fR corresponds to \f(CW@string\fR
entries; and \f(CWBTE_REGULAR\fR corresponds to any other type.)
.Sp
Returns \f(CWBTE_UNKNOWN\fR if \f(CWentry\fR is invalid (i.e., \f(CWNULL\fR or not a
pointer to an entry \s-1AST\s0).
.Ip "bt_entry_type()" 4
.Sp
.Vb 1
\&   char * bt_entry_type (AST * entry)
.Ve
Returns the type of an entry.  Recall that the type is the name that
appears after the \f(CW'@'\fR character in the original input.  Returns
\f(CWNULL\fR if \f(CWentry\fR is invalid (i.e., \f(CWNULL\fR or not a pointer to an
entry \s-1AST\s0).
.Ip "bt_entry_key()" 4
.Sp
.Vb 1
\&   char * bt_entry_key (AST * entry)
.Ve
Returns the citation key of a regular entry.  (The citation key is the
name that appears after the entry-open delimiter in a regular entry.)
Returns \f(CWNULL\fR if \f(CWentry\fR is invalid (i.e., \f(CWNULL\fR or not a pointer
to the \s-1AST\s0 for a regular entry).
.Ip "bt_get_text()" 4
.Sp
.Vb 1
\&   char * bt_get_text (AST * node)
.Ve
Performs all string post-processing (macro expansion, concatenation of
simple values, and whitespace collapsing) of a compound value and
returns the string that results.  Can be called either on a field for a
regular or macro definition entry (as returned by \f(CWbt_next_field()\fR),
or on a comment or preamble entry.  Returns \f(CWNULL\fR if called on an
invalid \s-1AST\s0 node.
.SH "SEE ALSO"
the \fIbtparse\fR manpage, the \fIbt_input\fR manpage, the \fIbt_postprocess\fR manpage
.SH "AUTHOR"
Greg Ward <gward@python.net>

.rn }` ''
.IX Title "bt_traversal 3"
.IX Name "bt_traversal - AST traversal/query functions in B<btparse> library"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Subsection "Traversal functions"

.IX Item "bt_next_entry()"

.IX Item "bt_next_field()"

.IX Item "bt_next_value()"

.IX Subsection "Query functions"

.IX Item "bt_entry_metatype()"

.IX Item "bt_entry_type()"

.IX Item "bt_entry_key()"

.IX Item "bt_get_text()"

.IX Header "SEE ALSO"

.IX Header "AUTHOR"

